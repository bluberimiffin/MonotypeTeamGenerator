/*
 * Andre Casiano
 * CSE 154 AC
 * 5 May 2022
 * Generates a team of pokemon that all share the selected type. Pokemon will have four or less
 * unique moves (only less if the pokemon can't learn at least four unique moves). They will
 * also be given a random level from 12 to 59, and a unique ability.
 */
"use strict";
(function() {
  window.addEventListener('load', init);

  const typeURL = "https://pokeapi.co/api/v2/type/";
  const pokeURL = "https://pokeapi.co/api/v2/pokemon/";

  /**
   * Adds functionality to the submit button on screen when the page has loaded.
   */
  function init() {
    qs("input").addEventListener('click', createTeam);
  }

  /**
   * When the createTeam button has loaded, creates a pokemon team of six pokemon
   * that share the type that was selected from the dropdown list. There can be duplicate
   * pokemon, but there cannot be duplicate moves. Removes previous error message
   * if it exists.
   */
  function createTeam() {
    id('error').classList.add('hidden');
    id("team-display").innerHTML = "";
    let pokeType = id("type-list").value;
    fetch(typeURL + pokeType)
      .then(checkStatus)
      .then(resp => resp.json())
      .then(getPokemonList)
      .then(getTeamInfo)
      .then(completeTeam)
      .then(displayTeam)
      .catch(handleError);
  }

  /**
   * Given info on a specific pokemon type, getPokemonList gets six pokemon that share that
   * pokemon type to create a pokemon team.
   * @param {object} info - all of the info about a specific pokemon type from pokeAPI.
   * @returns {array} - an array of the names of six pokemon that share the type from info.
   */
  function getPokemonList(info) {
    let team = [];
    const teamSize = 6;
    let pokemon = "";
    for (let i = 0; i < teamSize; i++) {
      pokemon = getPokemonName(info);
      team.push(pokemon);
      while (!checkTeam(team)) {
        team.pop();
        pokemon = getPokemonName(info);
        team.push(pokemon);
      }
    }
    return team;
  }

  /**
   * Gets information about all of the pokemon generated by the team from the pokeAPI.
   * @param {array} team - an array of strings of the names of the pokemon on the team.
   * @returns {array} - an array of all of the info about the pokemon from the generated list
   *    of pokemon names received from getPokemonList.
   */
  async function getTeamInfo(team) {
    let teamInfo = [];
    teamInfo[0] = await getPokeInfo(team[0]);
    teamInfo[1] = await getPokeInfo(team[1]);
    teamInfo[2] = await getPokeInfo(team[2]);
    teamInfo[3] = await getPokeInfo(team[3]);
    teamInfo[4] = await getPokeInfo(team[4]);
    teamInfo[5] = await getPokeInfo(team[5]);
    return teamInfo;
  }

  /**
   * Gets information about pokemon by their name from pokeAPI server.
   * @param {string} name - name of pokemon whose information will be retreived from the pokeAPI
   * @returns {object} - returns info collected from pokeAPI of that pokemon. Will return
   *           a console statement if any error occurs.
   */
  async function getPokeInfo(name) {
    try {
      let pokeInfo = await fetch(pokeURL + name);
      let okay = await checkStatus(pokeInfo);
      let parsedOkay = await okay.json();
      return parsedOkay;
    } catch (err) {
      handleError();
    }
  }

  /**
   * Displays an error message to user if something wrong happens when trying to get information
   * from the pokeAPI.
   */
  function handleError() {
    id('error').classList.remove('hidden');
  }

  /**
   * Checks if a team is valid based on if all of the pokemon are obtainable. Team is also invalid
   * if it has gmax, more than one mega, or has mimikyu busted, which is not a unique mimikyu
   * form but one that just occurs during battle (all mimikyu are mimikyu-disguised on a team).
   * @param {array} team - an array of the names of pokemon generated by
   * @returns {boolean} whether a pokemon team generated is valid in terms of the pokemon chosen.
   *      No pokemon should be totems, gmax. Also, mimikyu-busted should not be on one's team
   *      since it should default to mimikyu disguise.
   */
  function checkTeam(team) {
    let megaCount = 0;
    if (team.includes("mimikyu-busted")) {
      return false;
    }
    for (let i = 0; i < team.length; i++) {
      let name = team[i];
      if (name.includes("mega")) {
        megaCount++;
      } else if (name.includes("totem")) {
        return false;
      } else if (name.includes("gmax")) {
        return false;
      }
    }
    return megaCount <= 1;
  }

  /**
   * Adds little cards with pokemon info onto the screen for the user to see their team.
   * @param {array} team - contains a list of all of the information about the generated
   *    characteristics of the generated pokemon on a generated team.
   */
  function displayTeam(team) {
    for (let i = 0; i < team.length; i++) {
      displayPokemon(team[i]);
    }
  }

  /**
   * Displays the generated team onto the website.
   * @param {array} info -an array that represents all of the info about a pokemon generated for
   * one's pokemon team by addInfo.
   */
  function displayPokemon(info) {
    let teamSlot = gen('div');
    let sprite = gen('img');
    sprite.src = info[4];
    sprite.alt = "picture of " + info[0];
    teamSlot.appendChild(sprite);
    let text = gen('div');
    let name = gen('h3');
    name.textContent = info[0];
    text.appendChild(name);
    let ability = gen('p');
    ability.textContent = "ability: " + info[1];
    text.appendChild(ability);
    let level = gen('p');
    level.textContent = "level: " + info[2];
    text.appendChild(level);
    let moveLabel = gen('p');
    moveLabel.textContent = "moves:";
    text.appendChild(moveLabel);
    let moves = gen('ul');
    for (let i = 0; i < info[3].length; i++) {
      let move = gen('li');
      move.textContent = info[3][i];
      moves.appendChild(move);
    }
    text.appendChild(moves);
    teamSlot.appendChild(text);
    teamSlot.classList.add("team-slot");
    id("team-display").appendChild(teamSlot);
  }

  /**
   * Generates characteristics for every pokemon on the generated team.
   * @param {array} teamInfo - array of all of the info about each of the pokemon on the team.
   * @returns {array} - array of all of the pokemon on the generated team with generated
   *    characteristics like an ability, level, and moves.
   */
  function completeTeam(teamInfo) {
    let finishedTeam = [];
    for (let i = 0; i < teamInfo.length; i++) {
      let pokemon = completePokemon(teamInfo[i]);
      finishedTeam.push(pokemon);
    }
    return finishedTeam;
  }

  /**
   * Assigns a pokemon on one's team an ability, a level and a list of moves. The ability and
   * moves that are chosen are randomly chosen but are limited to a pokemon'e legal abilities
   * and moves. The level generated is from 12 to 59, which is type typical level range of
   * gym leaders.
   * @param {object} info -all of the info obtained from pokeAPI about a specific pokemon.
   * @returns {array} - an array representing the generated characteristics of one of the generated
   * pokemon on the generated team.
   */
  function completePokemon(info) {
    let name = info.name;
    let abilityNum = info.abilities.length;
    let ability = info.abilities[Math.floor(Math.random() * abilityNum)].ability.name;
    const baseLevel = 12;
    const maxLevel = 59;
    let level = Math.floor(baseLevel + Math.random() * (maxLevel - baseLevel));
    let moveList = [];
    let moveNum = info.moves.length;
    const totalMoves = 4;
    if (moveNum > totalMoves) {
      moveNum = totalMoves;
    }
    for (let i = 0; i < moveNum; i++) {
      let move = "";
      move = info.moves[Math.floor(Math.random() * moveNum)].move.name;
      moveList.push(move);
      while (!checkMoves(moveList)) {
        moveList.pop();
        move = info.moves[Math.floor(Math.random() * moveNum)].move.name;
        moveList.push(move);
      }
    }
    let spriteURL = info.sprites.front_default;
    let newPokemon = [name, ability, level, moveList, spriteURL];
    return newPokemon;
  }

  /**
   * Checks whether a pokemon has four unique moves. Returns true if it does, false if not.
   * @param {array} moves - the moves that have been assigned a pokemon by the completePokemon
   * function.
   * @returns {boolean} - false if a pokemon has a duplicate move. True if not.
   */
  function checkMoves(moves) {
    for (let i = 0; i < moves.length; i++) {
      for (let j = 0; j < moves.length; j++) {
        if (j !== i) {
          if (moves[i] === moves[j]) {
            return false;
          }
        }
      }
    }
    return true;
  }

  /**
   * Chooses a random pokemon from the list of all pokemon of a certain type.
   * @param {object} info - contains all of the information about a pokemon obtained from the
   * PokeAPI.
   * @returns{string} - name of randomly chosen pokemon.
   */
  function getPokemonName(info) {
    let totalPokemon = info.pokemon.length;
    let pokeNum = Math.floor(Math.random() * totalPokemon);
    let pokeName = info.pokemon[pokeNum].pokemon.name;
    return pokeName;
  }

  /**
   * Returns an element on the page that has that ID.
   * @param {string} id - id of element intended to be returned.
   * @returns {Element} - an element with given id.Null if no element found.
   */
  function id(id) {
    return document.getElementById(id);
  }

  /**
   * Returns the first element on the page that corresponds to the given query selector.
   * @param {string} selector - the query selector that will be used to find an element.
   * @returns {Element} element that corresponds with query selector. Null if no element matches.
   */
  function qs(selector) {
    return document.querySelector(selector);
  }

  /**
   * Returns a new element of given type.
   * @param {string} tagName - the type of tag that will be created.
   * @returns {Element} element of type of the given tagName. Null if the tagName is not recognized.
   */
  function gen(tagName) {
    return document.createElement(tagName);
  }

  /**
   * Returns an error if a fetch request is not fulfilled with a 200 ok status.
   * @param {object} res - a response object from a fetch request.
   * @returns {object} - error if fetch request doesn't have 200 ok status. Returns the response
   * if it does.
   */
  async function checkStatus(res) {
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res;
  }
})();
